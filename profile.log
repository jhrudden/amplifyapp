SCRIPT  /home/jhrudd/.vim/plugged/coc.nvim/autoload/coc/highlight.vim
Sourced 1 time
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000005 let s:is_vim = !has('nvim')
    1              0.000004 let s:clear_match_by_window = has('nvim-0.5.0') || has('patch-8.1.1084')
    1              0.000002 let s:namespace_map = {}
    1              0.000001 let s:ns_id = 1
                            
    1              0.000002 if has('nvim-0.5.0')
    1              0.000001   try
    1              0.000003     call getmatches(0)
                              catch /^Vim\%((\a\+)\)\=:E118/
                                let s:clear_match_by_window = 0
    1              0.000001   endtry
    1              0.000001 endif
                            
                            " highlight LSP range,
    1              0.000003 function! coc#highlight#ranges(bufnr, key, hlGroup, ranges) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr) || !exists('*getbufline')
                                return
                              endif
                              let srcId = s:create_namespace(a:key)
                              for range in a:ranges
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
                                endfor
                              endfor
                            endfunction
                            
    1              0.000002 function! coc#highlight#add_highlight(bufnr, src_id, hl_group, line, col_start, col_end) abort
                              if has('nvim')
                                call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
                              endif
                            endfunction
                            
    1              0.000002 function! coc#highlight#clear_highlight(bufnr, key, start_line, end_line) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr)
                                return
                              endif
                              let src_id = s:create_namespace(a:key)
                              if has('nvim')
                                call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
                              endif
                            endfunction
                            
                            " highlight buffer in winid with CodeBlock &HighlightItems
                            " export interface HighlightItem {
                            "   lnum: number // 0 based
                            "   hlGroup: string
                            "   colStart: number // 0 based
                            "   colEnd: number
                            " }
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000002 function! coc#highlight#add_highlights(winid, codes, highlights) abort
                              " clear highlights
                              call coc#compat#execute(a:winid, 'syntax clear')
                              let bufnr = winbufnr(a:winid)
                              call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
                              if !empty(a:codes)
                                call coc#highlight#highlight_lines(a:winid, a:codes)
                              endif
                              if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
                              endif
                            endfunction
                            
                            
                            " Add highlights to line groups of winid, support hlGroup and filetype
                            " config should have startLine, endLine (1 based, end excluded) and filetype or hlGroup
                            " endLine should > startLine and endLine is excluded
                            "
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    1              0.000002 function! coc#highlight#highlight_lines(winid, blocks) abort
                              let currwin = win_getid()
                              let switch = has('nvim') && currwin != a:winid
                              if switch
                                noa call nvim_set_current_win(a:winid)
                              endif
                              let defined = []
                              let region_id = 1
                              for config in a:blocks
                                let start = config['startLine'] + 1
                                let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
                                let filetype = get(config, 'filetype', '')
                                let hlGroup = get(config, 'hlGroup', '')
                                if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
                                else
                                  let filetype = matchstr(filetype, '\v^\w+')
                                  if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
                                  endif
                                  if index(defined, filetype) == -1
                                    call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
                                    if has('nvim')
                                      unlet! b:current_syntax
                                    elseif exists('*win_execute')
                                      call win_execute(a:winid, 'unlet! b:current_syntax')
                                    endif
                                    call add(defined, filetype)
                                  endif
                                  call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype))
                                  let region_id = region_id + 1
                                endif
                              endfor
                              if switch
                                noa call nvim_set_current_win(currwin)
                              endif
                            endfunction
                            
                            " Copmpose hlGroups with foreground and background colors.
    1              0.000001 function! coc#highlight#compose_hlgroup(fgGroup, bgGroup) abort
                              let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
                              if a:fgGroup == a:bgGroup
                                return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup
                            endfunction
                            
                            " add matches for winid, use 0 for current window.
    1              0.000002 function! coc#highlight#match_ranges(winid, bufnr, ranges, hlGroup, priority) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
                              if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
                              endif
                              if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
                              endif
                              let ids = []
                              for range in a:ranges
                                let list = []
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call add(list, [lnum, colStart, colEnd - colStart])
                                endfor
                                if !empty(list)
                                  let opts = s:clear_match_by_window ? {'window': a:winid} : {}
                                  let id = matchaddpos(a:hlGroup, list, a:priority, -1, opts)
                                  call add(ids, id)
                                endif
                              endfor
                              if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
                              endif
                              return ids
                            endfunction
                            
                            " Clear matches by hlGroup regexp.
    1              0.000002 function! coc#highlight#clear_match_group(winid, match) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Clear matches by match ids, use 0 for current win.
    1              0.000001 function! coc#highlight#clear_matches(winid, ids)
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                for id in a:ids
                                  try
                                    call matchdelete(id, winid)
                                  catch /^Vim\%((\a\+)\)\=:E803/
                                    " ignore
                                  endtry
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  for id in a:ids
                                    try
                                      call matchdelete(id)
                                    catch /^Vim\%((\a\+)\)\=:E803/
                                      " ignore
                                    endtry
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Sets the highlighting for the given group
    1              0.000002 function! s:create_gui_hlgroup(group, fg, bg, attr)
                              if a:fg != ""
                                exec "silent hi " . a:group . " guifg=" . a:fg . " ctermfg=" . coc#color#rgb2term(strpart(a:fg, 1))
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " guibg=" . a:bg . " ctermbg=" . coc#color#rgb2term(strpart(a:bg, 1))
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                              endif
                            endfun
                            
    1              0.000002 function! s:create_cterm_hlgroup(group, fg, bg, attr) abort
                              if a:fg != ""
                                exec "silent hi " . a:group . " ctermfg=" . a:fg
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " ctermbg=" . a:bg
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " cterm=" . a:attr
                              endif
                            endfunction
                            
    1              0.000002 function! s:execute(winid, cmd) abort
                              if has('nvim')
                                execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
                              endif
                            endfunction
                            
    1              0.000001 function! s:create_namespace(key) abort
                              if type(a:key) == 0
                                return a:key
                              endif
                              if has('nvim')
                                return nvim_create_namespace('coc-'.a:key)
                              endif
                              if !has_key(s:namespace_map, a:key)
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]
                            endfunction

FUNCTION  <SNR>101_isEOF()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:128
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000008     return len(a:data) == 1 && a:data[0] is# ''

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 4 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    4              0.000027   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    4              0.000002   endif

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:146
Called 114 times
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
  114              0.000200   if s:is_vim
                                return a:client['channel']
  114              0.000053   endif
  114              0.000192   return a:client['chan_id']

FUNCTION  3()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 63 times
Total time:   0.004028
 Self time:   0.002825

count  total (s)   self (s)
   63   0.001275   0.000483     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
   63              0.000079     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
   63              0.000036     endif
                            
   63              0.000123     let self._bookmarkNames = []
   63   0.000774   0.000364     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
   63              0.000053     endfor
   63              0.000179     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
   63              0.000036     endif
                            
   63              0.000073     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
   63              0.000034     endif
                            
   63              0.000070     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
   63              0.000034     endif

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim:211
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000003   let winid = a:winid == 0 ? win_getid() : a:winid
    1              0.000006   if empty(getwininfo(winid))
                                " not valid
                                return
    1              0.000000   endif
    1              0.000001   if s:clear_match_by_window
    1              0.000005     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
    1              0.000001     for item in arr
                                  call matchdelete(item['id'], winid)
    1              0.000001     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
    1              0.000000   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:93
Called 8 times
Total time:   0.006934
 Self time:   0.000641

count  total (s)   self (s)
   48              0.000054     for Fn in a:list
   48   0.006732   0.000438       let code = call(Fn, a:000)
   48              0.000048       if code != 0
    8              0.000008         return code
   40              0.000018       endif
   40              0.000020     endfor
                                return 0

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:11
Called 4 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    4              0.000014   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    4              0.000002   endif

FUNCTION  <SNR>90_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:155
Called 32 times
Total time:   0.028691
 Self time:   0.000512

count  total (s)   self (s)
   32   0.009961   0.000230   if airline#builder#should_change_group(a:prev_group, a:group)
   32   0.018710   0.000263     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>115_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 4 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    4              0.000009   if has('unix')
    4              0.000011     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 7 times
Total time:   0.010427
 Self time:   0.000539

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    7   0.001500   0.000068   if gitgutter#utility#is_active(a:bufnr)
                            
    7              0.000034     if has('patch-7.4.1559')
    7              0.000047       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    7              0.000004     endif
    7   0.000372   0.000064     let how = s:setup_path(a:bufnr, l:Callback)
    7              0.000017     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
    7              0.000004     endif
                            
    7   0.000079   0.000031     if a:force || s:has_fresh_changes(a:bufnr)
                            
    4              0.000007       let diff = 'NOT SET'
    4              0.000004       try
    4   0.008164   0.000064         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    4              0.000005       endtry
                            
    4              0.000009       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    4              0.000002       endif
                            
    7              0.000003     endif
    7              0.000003   endif

FUNCTION  <SNR>86_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:195
Called 7 times
Total time:   0.001279
 Self time:   0.001279

count  total (s)   self (s)
    7              0.000021   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    7              0.000007   if bidx_mode > 0
    7              0.000006     if bidx_mode == 1
   77              0.000072       for i in range(1, 10)
   70              0.000932         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i%10, i-1)
   77              0.000037       endfor
                                else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
    7              0.000004     endif
    7              0.000058     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    7              0.000048     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    7              0.000003   endif

FUNCTION  <SNR>34_refreshGitStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:149
Called 3 times
Total time:   0.003214
 Self time:   0.000078

count  total (s)   self (s)
    3              0.000024     let l:opts =  { 'on_failed_cb': function('s:onGitStatusFailedCB'), 'on_success_cb': function('s:onGitStatusSuccessCB'), 'cwd': a:workdir }
    3   0.003182   0.000046     let l:job = gitstatus#job#Spawn(a:name, s:buildGitStatusCommand(a:workdir), l:opts)
    3              0.000004     return l:job

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:14
Called 158 times
Total time:   0.004219
 Self time:   0.000989

count  total (s)   self (s)
  158   0.004130   0.000900   return airline#extensions#coc#get('error')

FUNCTION  <SNR>117_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 12 times
Total time:   0.000974
 Self time:   0.000974

count  total (s)   self (s)
   12              0.000013   let offset = 0
  168              0.000164   while offset < a:to_count
  156              0.000196     let line_number = a:to_line + offset
  156              0.000306     call add(a:modifications, [line_number, 'added'])
  156              0.000139     let offset += 1
  168              0.000068   endwhile

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:190
Called 167 times
Total time:   0.002458
 Self time:   0.002458

count  total (s)   self (s)
  167              0.000928   if has_key(s:contexts, a:winnr)
  167              0.001311     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:199
Called 167 times
Total time:   0.121549
 Self time:   0.017977

count  total (s)   self (s)
  167              0.000417   if !has_key(s:contexts, a:winnr)
                                return ''
  167              0.000108   endif
  167              0.000417   let context = s:contexts[a:winnr]
                            
  167              0.000448   if get(w:, 'airline_active', 1)
  158              0.000383     let l:m = mode(1)
  158              0.000214     if l:m ==# "i"
                                  let l:mode = ['insert']
  158              0.000251     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
  158              0.000172     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
  158              0.000195     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
  158              0.001058     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
  158              0.000169     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
  158              0.000183     elseif l:m[0] ==# "c"
    4              0.000009       let l:mode = ['commandline']
  154              0.000166     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
  154              0.000221     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
  154              0.000071     else
  154              0.000271       let l:mode = ['normal']
  158              0.000091     endif
  158              0.000501     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  158              0.000071     endif
  158              0.000799     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  158              0.000255       let l:m = l:m[0]
  158              0.000076     endif
  158              0.000597     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    9              0.000005   else
    9              0.000014     let l:mode = ['inactive']
    9              0.000033     let w:airline_current_mode = get(g:airline_mode_map, '__')
  167              0.000078   endif
                            
  167              0.000502   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
  167              0.000082   endif
                            
  167              0.000269   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  167              0.000071   endif
                            
  167              0.001541   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  167              0.000072   endif
                            
  167              0.000286   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  167              0.000071   endif
                            
  167              0.000217   if &readonly || ! &modifiable
    9              0.000022     call add(l:mode, 'readonly')
  167              0.000080   endif
                            
  167              0.000521   let mode_string = join(l:mode)
  167              0.000451   if get(w:, 'airline_lastmode', '') != mode_string
    8   0.002228   0.000088     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    8   0.100968   0.000162     call airline#highlighter#highlight(l:mode, context.bufnr)
    8   0.000735   0.000109     call airline#util#doautocmd('AirlineModeChanged')
    8              0.000019     let w:airline_lastmode = mode_string
  167              0.000069   endif
                            
  167              0.000130   return ''

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:49
Called 1106 times
Total time:   0.009596
 Self time:   0.009596

count  total (s)   self (s)
 1106              0.002289   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1106              0.000472   endif
 1106              0.002550   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1106              0.002689   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:203
Called 4 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    4              0.000019   let dt = localtime() - s:focusgained_ignore_time
    4              0.000008   let s:focusgained_ignore_time = 0
    4              0.000005   return dt >= 1

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 228 times
Total time:   0.034118
 Self time:   0.001933

count  total (s)   self (s)
  228   0.034033   0.001848   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:279
Called 8 times
Total time:   0.000213
 Self time:   0.000172

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    8              0.000103   let g:airline#visual_active = (mode() =~? '[vs]')
    8   0.000086   0.000045   call airline#update_tabline()

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:1211
Called 104 times
Total time:   0.001858
 Self time:   0.001858

count  total (s)   self (s)
  104              0.000903   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
  104              0.000116   endfor
  104              0.000141   return 0

FUNCTION  <SNR>51_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:83
Called 104 times
Total time:   0.002098
 Self time:   0.001507

count  total (s)   self (s)
  104              0.000496   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
  104              0.000055   endif
  104   0.001193   0.000602   call airline#update_tabline()

FUNCTION  <SNR>102_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 7 times
Total time:   0.000308
 Self time:   0.000065

count  total (s)   self (s)
    7   0.000304   0.000061   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:10
Called 158 times
Total time:   0.004788
 Self time:   0.001063

count  total (s)   self (s)
  158   0.004704   0.000979   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:46
Called 158 times
Total time:   0.004783
 Self time:   0.001234

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
  158   0.004622   0.001074   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  <SNR>117_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 4 times
Total time:   0.000663
 Self time:   0.000663

count  total (s)   self (s)
    4              0.000068   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    4              0.000014   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    4              0.000002   endif
                            
    4              0.000016   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    4              0.000002   endif
                            
    4              0.000010   if getbufvar(a:bufnr, '&endofline')
    4              0.000012     call add(bufcontents, '')
    4              0.000003   endif
                            
    4              0.000013   let fenc = getbufvar(a:bufnr, '&fileencoding')
    4              0.000008   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    4              0.000002   endif
                            
    4              0.000010   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    4              0.000002   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    4              0.000003   try
    4              0.000390     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    4              0.000005   endtry

FUNCTION  nerdtree#slash()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:47
Called 171 times
Total time:   0.003604
 Self time:   0.002291

count  total (s)   self (s)
  171   0.002447   0.001134     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
  171              0.000087     endif
                            
  171              0.000150     return '/'

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim:51
Called 7 times
Total time:   0.001451
 Self time:   0.000171

count  total (s)   self (s)
    7              0.000007   try
    7   0.001323   0.000043     call <sid>map_keys()
                              catch
                                " no-op
    7              0.000006   endtry
    7              0.000017   let cur = bufnr('%')
    7              0.000027   if cur == s:current_bufnr && &columns == s:column_width
    7              0.000033     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    7              0.000013       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim:35
Called 4 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    4              0.000095   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  <SNR>90_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:163
Called 44 times
Total time:   0.001645
 Self time:   0.001645

count  total (s)   self (s)
   44              0.000055   if a:self._context.active
                                " active window
   32              0.000036     let contents = []
   32              0.000164     let content_parts = split(a:contents, '__accent')
   88              0.000087     for cpart in content_parts
   56              0.000254       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   56              0.000108       call add(contents, cpart)
   88              0.000047     endfor
   32              0.000090     let line = join(contents, a:group)
   32              0.000165     let line = substitute(line, '__restore__', a:group, 'g')
   12              0.000007   else
                                " inactive window
   12              0.000099     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   12              0.000058     let line = substitute(line, '%#__restore__#', '', 'g')
   44              0.000020   endif
   44              0.000042   return line

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 4 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
    4              0.000079   let p = resolve(expand('#'.a:bufnr.':p'))
    4              0.000053   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    4              0.000013   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    4              0.000003   endif
    4              0.000008   return g:gitgutter_diff_base

FUNCTION  <SNR>77_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:96
Called 302 times
Total time:   0.003671
 Self time:   0.003671

count  total (s)   self (s)
  302              0.001190   if !hlexists(a:group)
                                return 0
  302              0.001483   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  302              0.000127   endif
  302              0.000203   return 1

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 158 times
Total time:   0.002551
 Self time:   0.001405

count  total (s)   self (s)
  158   0.002434   0.001288   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 158 times
Total time:   0.000916
 Self time:   0.000916

count  total (s)   self (s)
  158              0.000383   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  158              0.000070   endif
  158              0.000109   return ''

FUNCTION  <SNR>41_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 11 times
Total time:   0.000721
 Self time:   0.000198

count  total (s)   self (s)
   11   0.000713   0.000190   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:273
Called 116 times
Total time:   0.000650
 Self time:   0.000650

count  total (s)   self (s)
  116              0.000314   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
  116              0.000054   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:14
Called 4 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    4              0.000016   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    4              0.000002   endif

FUNCTION  <SNR>102_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 3 times
Total time:   0.000048
 Self time:   0.000024

count  total (s)   self (s)
    3   0.000047   0.000023   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 4 times
Total time:   0.005089
 Self time:   0.004901

count  total (s)   self (s)
    4   0.000204   0.000040   call gitgutter#debug#log('[async] '.a:cmd)
                            
    4              0.000021   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    4   0.000060   0.000037   let command = s:build_command(a:cmd)
                            
    4              0.000012   if has('nvim')
    4              0.004726     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    4              0.000003   endif

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 186 times
Total time:   0.004200
 Self time:   0.001967

count  total (s)   self (s)
  186   0.004064   0.001832   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim:18
Called 316 times
Total time:   0.006955
 Self time:   0.006955

count  total (s)   self (s)
  316              0.000854   if !exists(':CocCommand')
                                return ''
  316              0.000133   endif
  316              0.000774   let _backup = get(g:, 'coc_stl_format', '')
  316              0.000571   let is_err = (a:type  is# 'error')
  316              0.000275   if is_err
  158              0.000569     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  158              0.000068   else
  158              0.000593     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  316              0.000147   endif
  316              0.000725   let info = get(b:, 'coc_diagnostic_info', {})
  316              0.000660   if empty(info) | return '' | endif
                            
                            
                              let cnt = get(info, a:type, 0)
                              if !empty(_backup)
                                let g:coc_stl_format = _backup
                              endif
                            
                              if empty(cnt)
                                return ''
                              else
                                let lnum = printf('(L%d)', (info.lnums)[0])
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt.lnum
                              endif

FUNCTION  <SNR>117_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 4 times
Total time:   0.000083
 Self time:   0.000033

count  total (s)   self (s)
    4   0.000080   0.000030   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>47_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:112
Called 3 times
Total time:   0.000555
 Self time:   0.000136

count  total (s)   self (s)
    3              0.000038   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    3              0.000012   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    3              0.000003   endif
    3   0.000453   0.000034   call coc#rpc#notify(a:name, a:args)
    3              0.000004   return ''

FUNCTION  308()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:42
Called 3 times
Total time:   0.000038
 Self time:   0.000029

count  total (s)   self (s)
    3   0.000025   0.000015     let self.failed = self.failed || !s:isEOF(a:data)
    3              0.000006     let self.err_chunks[-1] .= a:data[0]
    3              0.000005     call extend(self.err_chunks, a:data[1:])

FUNCTION  309()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:48
Called 3 times
Total time:   0.000642
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000004     let self.running = 0
    3              0.000002     if self.failed
                                    call self.onFailed()
    3              0.000001     else
    3   0.000627   0.000009         call self.onSuccess()
    3              0.000001     endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 8 times
Total time:   0.000796
 Self time:   0.000453

count  total (s)   self (s)
    8              0.000033   let filetype_overrides = get(s:, 'filetype_overrides', {})
    8              0.000041   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    8   0.000399   0.000057   if s:is_excluded_window()
                                return -1
    8              0.000004   endif
                            
    8              0.000011   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    8              0.000003   endif
                            
    8              0.000021   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    8              0.000004   endif
                            
    8              0.000055   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    8              0.000004   endif
                            
    8              0.000009   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    8              0.000004   endif
                            
    8              0.000025   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    8              0.000005   endfor

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 7 times
Total time:   0.000243
 Self time:   0.000077

count  total (s)   self (s)
    7   0.000238   0.000073   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  12()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 48 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   48              0.000065     if self.cachedDisplayString ==# ''
                                    call self.cacheDisplayString()
   48              0.000022     endif
                            
   48              0.000049     return self.cachedDisplayString

FUNCTION  19()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 300 times
Total time:   0.002844
 Self time:   0.002844

count  total (s)   self (s)
  300              0.000501     if empty(self.pathSegments)
                                    return ''
  300              0.000139     endif
  300              0.000535     let toReturn = self.pathSegments[-1]
  300              0.000410     if a:dirSlash && self.isDirectory
   21              0.000057         let toReturn = toReturn . '/'
  300              0.000134     endif
  300              0.000298     return toReturn

FUNCTION  <SNR>117_process_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:333
Called 4 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    4              0.000004   let offset = 0
    8              0.000009   while offset < a:to_count
    4              0.000007     let line_number = a:to_line + offset
    4              0.000010     call add(a:modifications, [line_number, 'modified'])
    4              0.000028     let offset += 1
    8              0.000005   endwhile
    4              0.000012   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  311()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:63
Called 3 times
Total time:   0.000618
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000006     if has_key(self.opts, 'on_success_cb')
    3   0.000609   0.000023         call call(self.opts.on_success_cb, [self])
    3              0.000001     endif

FUNCTION  <SNR>92_getStatusKey()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:149
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000005     let l:xy = a:x . a:y
    3              0.000005     if get(s:unmerged_status, l:xy, 0)
                                    return 'Unmerged'
    3              0.000003     elseif l:xy ==# '??'
                                    return 'Untracked'
    3              0.000002     elseif l:xy ==# '!!'
                                    return 'Ignored'
    3              0.000002     elseif a:y ==# 'M'
    3              0.000002         return 'Modified'
                                elseif a:y ==# 'D'
                                    return 'Deleted'
                                elseif a:y =~# '[RC]'
                                    return 'Renamed'
                                elseif a:x ==# 'D'
                                    return 'Deleted'
                                elseif a:x =~# '[MA]'
                                    return 'Staged'
                                elseif a:x =~# '[RC]'
                                    return 'Renamed'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  airline#extensions#tabline#formatters#webdevicons#format()
    Defined: ~/.vim/plugged/vim-devicons/autoload/airline/extensions/tabline/formatters/webdevicons.vim:6
Called 7 times
Total time:   0.001837
 Self time:   0.000180

count  total (s)   self (s)
                              " Call original formatter.
    7   0.000618   0.000084   let originalFormatter = airline#extensions#tabline#formatters#{g:_webdevicons_airline_orig_formatter}#format(a:bufnr, a:buffers)
    7   0.001205   0.000083   return originalFormatter . g:WebDevIconsTabAirLineBeforeGlyphPadding . WebDevIconsGetFileTypeSymbol(bufname(a:bufnr)) . g:WebDevIconsTabAirLineAfterGlyphPadding

FUNCTION  24()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:432
Called 117 times
Total time:   0.001672
 Self time:   0.000667

count  total (s)   self (s)
  117   0.001630   0.000625     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  26()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 120 times
Total time:   0.012108
 Self time:   0.004991

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  120   0.000618   0.000435     if a:nerdtree.ui.isIgnoreFilterEnabled()
  237              0.000252         for i in g:NERDTreeIgnore
  120   0.004841   0.000478             if self._ignorePatternMatches(i)
    3              0.000002                 return 1
  117              0.000052             endif
  234              0.000132         endfor
                            
  117   0.001075   0.000491         for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
  117              0.000067         endfor
  117              0.000054     endif
                            
                                "dont show hidden files unless instructed to
  117   0.002623   0.000785     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
    9              0.000007         return 1
  108              0.000046     endif
                            
  108   0.000608   0.000458     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
  108              0.000044     endif
                            
  108              0.000071     return 0

FUNCTION  27()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:484
Called 120 times
Total time:   0.004362
 Self time:   0.003316

count  total (s)   self (s)
  120              0.000172     let pat = a:pattern
  120              0.000318     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                    let pat = strpart(pat,0, len(pat)-8)
                                    return self.str() =~# pat
  120              0.000289     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
  120              0.000284     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
  120              0.000052     endif
                            
  120   0.001809   0.000762     return self.getLastPathComponent(0) =~# pat

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 4 times
Total time:   0.000590
 Self time:   0.000107

count  total (s)   self (s)
    4   0.000295   0.000067   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    4   0.000291   0.000036   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  111()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 36 times
Total time:   0.001100
 Self time:   0.000298

count  total (s)   self (s)
   36   0.001086   0.000284     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  112()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 18 times
Total time:   0.003184
 Self time:   0.000148

count  total (s)   self (s)
   18   0.003177   0.000141     return self.path.str() ==# a:treenode.path.str()

FUNCTION  115()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 201 times
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
  201              0.000246     return self._nerdtree

FUNCTION  119()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 18 times
Total time:   0.003497
 Self time:   0.000238

count  total (s)   self (s)
   18   0.000117   0.000069     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
   18              0.000007     endif
                            
   18   0.003339   0.000128     return self.equals(self.getNerdtree().root)

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:19
Called 1616 times
Total time:   0.012090
 Self time:   0.012090

count  total (s)   self (s)
 1616              0.003501   let nr = get(a:000, 0, 0)
 1616              0.003071   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 1616              0.000704   else
 1616              0.002391     return winwidth(nr)
                              endif

FUNCTION  <SNR>117_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 8 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    8              0.000012   return a:from_count > 0 && a:to_count == 0

FUNCTION  <SNR>90_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:140
Called 36 times
Total time:   0.020904
 Self time:   0.001002

count  total (s)   self (s)
   36              0.000043   let line = ''
   36              0.000128   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   36              0.000015   else
   36   0.020170   0.000269     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   36              0.000109     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   36              0.000099     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   36              0.000065     let line .= '%#'.a:group.'#'
   36              0.000016   endif
   36              0.000031   return line

FUNCTION  <SNR>41_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 7 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    7              0.000041   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:176
Called 12 times
Total time:   0.000760
 Self time:   0.000258

count  total (s)   self (s)
   12   0.000749   0.000247   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  307()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:37
Called 6 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    6              0.000015     let self.chunks[-1] .= a:data[0]
    6              0.000012     call extend(self.chunks, a:data[1:])

FUNCTION  36()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:648
Called 63 times
Total time:   0.052057
 Self time:   0.000898

count  total (s)   self (s)
   63   0.047643   0.000511     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
   63   0.004374   0.000346     call self.cacheDisplayString()

FUNCTION  38()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 174 times
Total time:   0.018481
 Self time:   0.009102

count  total (s)   self (s)
  174              0.000413     let options = a:0 ? a:1 : {}
  174              0.000239     let toReturn = ''
                            
  174              0.000383     if has_key(options, 'format')
    3              0.000005         let format = options['format']
    3              0.000007         if has_key(self, '_strFor' . format)
    3   0.000048   0.000020             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
    3              0.000002         endif
  171              0.000090     else
  171   0.009608   0.000912         let toReturn = self._str()
  174              0.000110     endif
                            
  174   0.001799   0.001145     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
  174              0.000092     endif
                            
  174              0.000338     if has_key(options, 'truncateTo')
    3              0.000005         let limit = options['truncateTo']
    3              0.000009         if strdisplaywidth(toReturn) > limit-1
   21              0.000071             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
   18              0.000072                 let toReturn = substitute(toReturn, '^.', '', '')
   21              0.000013             endwhile
    3              0.000014             if len(split(toReturn, '/')) > 1
    3              0.000019                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    3              0.000002             endif
    3              0.000001         endif
  174              0.000081     endif
                            
  174              0.000207     return toReturn

FUNCTION  39()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:735
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000011     let toReturn = '/' . join(self.pathSegments, '/')
    3              0.000005     if self.isDirectory && toReturn !=# '/'
    3              0.000005         let toReturn  = toReturn . '/'
    3              0.000001     endif
    3              0.000003     return toReturn

FUNCTION  128()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:288
Called 42 times
Total time:   0.030974
 Self time:   0.000347

count  total (s)   self (s)
   42   0.030956   0.000329     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  43()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 171 times
Total time:   0.008697
 Self time:   0.003969

count  total (s)   self (s)
  171   0.004677   0.001073     let l:separator = nerdtree#slash()
  171              0.000314     let l:leader = l:separator
                            
  171   0.002236   0.001112     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
  171              0.000091     endif
                            
  171              0.000810     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  gitstatus#util#FormatPath()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:45
Called 63 times
Total time:   0.007600
 Self time:   0.000386

count  total (s)   self (s)
   63   0.007569   0.000355         return a:path.str()

FUNCTION  130()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 3 times
Total time:   0.021666
 Self time:   0.000019

count  total (s)   self (s)
    3   0.021664   0.000017     return self._renderToString(0, 0)

FUNCTION  131()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 51 times
Total time:   0.041825
 Self time:   0.037443

count  total (s)   self (s)
   51              0.000058     let output = ''
   51              0.000055     if a:drawText ==# 1
                            
   48              0.000106         let treeParts = repeat('  ', a:depth - 1)
   48              0.000139         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
   48   0.008466   0.000235         let line = treeParts . self.displayString()
   48              0.000089         let output = output . line . "\n"
   51              0.000024     endif
                            
                                " if the node is an open dir, draw its children
   51              0.000078     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
    6   0.006778   0.000034         let childNodesToDraw = self.getVisibleChildren()
                            
    6   0.004738   0.000034         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
    6              0.000011         elseif len(childNodesToDraw) > 0
   54              0.000043             for i in childNodesToDraw
   48              0.000196                 let output = output . i._renderToString(a:depth + 1, 1)
   54              0.000030             endfor
    6              0.000003         endif
   51              0.000019     endif
                            
   51              0.000048     return output

FUNCTION  138()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 12 times
Total time:   0.007130
 Self time:   0.000471

count  total (s)   self (s)
   12              0.000015     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   12              0.000013     let l:label = ''
   12   0.006412   0.000052     let l:cascade = self.getCascade()
   24              0.000027     for l:dirNode in l:cascade
   12   0.000127   0.000062         let l:next = l:dirNode.path.displayString()
   12              0.000042         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
   24              0.000014     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   12              0.000040     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
   12              0.000028     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
   12   0.000302   0.000068     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   12              0.000025     return l:symbol . l:flags . l:label

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:208
Called 7 times
Total time:   0.002031
 Self time:   0.000160

count  total (s)   self (s)
    7   0.000093   0.000058   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    7              0.000021   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    7   0.001909   0.000073   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 20 times
Total time:   0.000426
 Self time:   0.000426

count  total (s)   self (s)
   20              0.000167   let matches = matchlist(a:line, s:hunk_re)
   20              0.000029   if len(matches) > 0
   20              0.000039     let from_line  = str2nr(matches[1])
   20              0.000049     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   20              0.000034     let to_line    = str2nr(matches[3])
   20              0.000046     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   20              0.000038     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 4 times
Total time:   0.000701
 Self time:   0.000275

count  total (s)   self (s)
    4              0.000006   let hunks = []
   24              0.000039   for line in split(a:diff, '\n')
   20   0.000551   0.000125     let hunk_info = gitgutter#diff#parse_hunk(line)
   20              0.000025     if len(hunk_info) == 4
   20              0.000031       call add(hunks, hunk_info)
   20              0.000008     endif
   24              0.000011   endfor
    4              0.000003   return hunks

FUNCTION  140()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 12 times
Total time:   0.006360
 Self time:   0.000072

count  total (s)   self (s)
   12   0.006338   0.000049     if !self.isCascadable()
   12              0.000014         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 4 times
Total time:   0.004327
 Self time:   0.000217

count  total (s)   self (s)
    4              0.000008   let modified_lines = []
   24              0.000019   for hunk in a:hunks
   20   0.004267   0.000157     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   24              0.000012   endfor
    4              0.000003   return modified_lines

FUNCTION  <SNR>117_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 8 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    8              0.000017   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:28
Called 474 times
Total time:   0.011286
 Self time:   0.007499

count  total (s)   self (s)
  474   0.007062   0.003275   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  474              0.000188   else
  474              0.000458     return a:text
                              endif

FUNCTION  gitstatus#job#Spawn()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:132
Called 3 times
Total time:   0.003021
 Self time:   0.000055

count  total (s)   self (s)
    3   0.000062   0.000023     let l:job = s:newJob(a:name, a:opts)
    3   0.002950   0.000023     call l:job.run(a:cmd)
    3              0.000005     return l:job

FUNCTION  150()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 21 times
Total time:   0.013744
 Self time:   0.001469

count  total (s)   self (s)
   21              0.000028     let toReturn = []
  141              0.000119     for i in self.children
  120   0.013104   0.000829         if i.path.ignore(self.getNerdtree()) ==# 0
  108              0.000202             call add(toReturn, i)
  120              0.000055         endif
  141              0.000072     endfor
   21              0.000018     return toReturn

FUNCTION  152()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 18 times
Total time:   0.010992
 Self time:   0.000419

count  total (s)   self (s)
   18              0.000026     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
   18              0.000008     endif
                            
   18   0.003565   0.000068     if self.isRoot()
    3              0.000002         return 0
   15              0.000006     endif
                            
   15              0.000016     if self.path.isSymLink
                                    return 0
   15              0.000006     endif
                            
   15   0.000145   0.000069     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self.path)
                                        return 0
                                    endif
   15              0.000010     endfor
                            
   15   0.007064   0.000065     let c = self.getVisibleChildren()
   15              0.000033     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 8 times
Total time:   0.004986
 Self time:   0.000439

count  total (s)   self (s)
    8              0.000015   let winnr = a:context.winnr
    8              0.000012   let active = a:context.active
                            
    8   0.000090   0.000063   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    8   0.002091   0.000076     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    8              0.000004   endif
                            
    8   0.000380   0.000085   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    8   0.000073   0.000050   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    4   0.002219   0.000034     call s:build_sections(a:builder, a:context, s:layout[1])
    8              0.000004   endif
                            
    8              0.000006   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:185
Called 12 times
Total time:   0.000385
 Self time:   0.000270

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
   12   0.000363   0.000249   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  <SNR>41_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 7 times
Total time:   0.000462
 Self time:   0.000107

count  total (s)   self (s)
    7   0.000458   0.000104   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  gitstatus#getIndicator()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:61
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000050     return get(get(g:, 'NERDTreeGitStatusIndicatorMapCustom', {}), a:status, s:indicatorMap[a:status])

FUNCTION  NERDTreeRender()
    Defined: ~/.vim/plugged/nerdtree/plugin/NERD_tree.vim:187
Called 3 times
Total time:   0.022994
 Self time:   0.000017

count  total (s)   self (s)
    3   0.022992   0.000015     call nerdtree#renderView()

FUNCTION  162()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:599
Called 21 times
Total time:   0.096308
 Self time:   0.000542

count  total (s)   self (s)
   21   0.021796   0.000235     call self.path.refreshFlags(self.getNerdtree())
   81              0.000121     for i in self.children
   60   0.031239   0.000265         call i.refreshFlags()
   81              0.000058     endfor

FUNCTION  <SNR>114_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 4 times
Total time:   0.000072
 Self time:   0.000028

count  total (s)   self (s)
    4   0.000069   0.000025   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:65
Called 594 times
Total time:   0.086213
 Self time:   0.035749

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
  594              0.003954   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  594              0.001785   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  594              0.000269   else
  594   0.015948   0.003531     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  594   0.015417   0.003505     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  594   0.015103   0.003389     let guifg = s:get_syn(a:group, 'fg', 'gui')
  594   0.014906   0.003357     let guibg = s:get_syn(a:group, 'bg', 'gui')
  594              0.003108     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  594              0.000522     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  594              0.000297     else
  594   0.007298   0.004427       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  594              0.000285     endif
  594              0.000242   endif
  594              0.001486   let s:hl_groups[a:group] = res
  594              0.000514   return res

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:604
Called 63 times
Total time:   0.028929
 Self time:   0.007435

count  total (s)   self (s)
   63              0.000129   let path = a:event.subject
   63              0.000152   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
   63              0.000154   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
   63   0.000925   0.000453   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
   63              0.000268   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
   63   0.001098   0.000552   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
   63              0.000179   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
   57              0.000115     let prePadding .= ' '
   63              0.000038   endif
                            
   63              0.000088   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
   42   0.011792   0.000542     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
   21              0.000059   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
   21              0.000044     let directoryOpened = 0
                            
   21              0.000091     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
   21              0.000014     endif
                            
   21              0.000050     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
   21              0.000046       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
   21              0.000017       else
                                    " the folder is not open
   21              0.000034         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
   21              0.000015         else
                                      " We have a regular folder
   21   0.008111   0.000409           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
   21              0.000018         endif
   21              0.000014       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
   21              0.000014     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
   63              0.000035   endif
                            
   63   0.000615   0.000358   call path.flagSet.clearFlags('webdevicons')
                            
   63              0.000096   if flag !=? ''
   63   0.001640   0.000373     call path.flagSet.addFlag('webdevicons', flag)
   63              0.000036   endif
                            

FUNCTION  81()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 78 times
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
   78              0.000208     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
   78              0.000041     endif
   78              0.000099     return g:NERDTreeBookmarks

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:42
Called 1747 times
Total time:   0.009767
 Self time:   0.008671

count  total (s)   self (s)
 1747   0.005175   0.004079   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1747              0.000754   endif
 1747              0.001682   return a:text

FUNCTION  <SNR>34_onGitStatusSuccessCB()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:160
Called 3 times
Total time:   0.000585
 Self time:   0.000098

count  total (s)   self (s)
    3              0.000010     if !exists('g:NTGitWorkdir') || g:NTGitWorkdir !=# a:job.opts.cwd
                                    call s:logger.debug(printf("git workdir has changed: '%s' -> '%s'", a:job.opts.cwd, get(g:, 'NTGitWorkdir', '')))
                                    return
    3              0.000001     endif
    3              0.000008     let l:output = join(a:job.chunks, '')
    3              0.000011     let l:lines = split(l:output, "\n")
    3   0.000400   0.000023     let l:cache = gitstatus#util#ParseGitStatusLines(a:job.opts.cwd, l:lines, g:)
                            
    3   0.000026   0.000018     call s:listener.SetNext(l:cache)
    3   0.000113   0.000011     call s:listener.TryUpdateNERDTreeUI()

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 8 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
    8              0.000012   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
    8              0.000005   endif

FUNCTION  312()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:70
Called 3 times
Total time:   0.002927
 Self time:   0.002927

count  total (s)   self (s)
    3              0.002881         let jid = jobstart(a:cmd, { 'on_stdout': {_job_id, data, _event  -> self.onStdoutCB(data)}, 'on_stderr': {_job_id, data, _event  -> self.onStderrCB(data)}, 'on_exit':   {_job_id, _data, _event -> self.onExitCB()}, 'env':       {'GIT_OPTIONAL_LOCKS': '0'}, })
    3              0.000010         let self.id = jid
    3              0.000007         let self.running = jid > 0
    3              0.000005         if jid <= 0
                                        let self.failed = 1
                                        let self.err_chunks = jid == 0 ? ['invalid arguments'] : ['command is not executable']
                                        call self.onExitCB()
    3              0.000003         endif

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim:149
Called 7 times
Total time:   0.001810
 Self time:   0.000359

count  total (s)   self (s)
    7              0.000028   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    7              0.000017   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    7              0.000020   let curtabcnt = tabpagenr('$')
    7              0.000014   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
    7              0.000003   endif
                            
    7              0.000022   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline(0)
    7              0.000003   endif
    7              0.000023   if !exists('#airline#SessionLoadPost')
                                autocmd airline SessionLoadPost * call <sid>update_tabline(1)
    7              0.000003   endif
    7              0.000006   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
    7              0.000007   elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
    7              0.000012   elseif show_buffers && curtabcnt == 1 || !show_tabs
    7   0.001512   0.000062     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 4 times
Total time:   0.000191
 Self time:   0.000040

count  total (s)   self (s)
    4   0.000189   0.000038   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:82
Called 96 times
Total time:   0.000319
 Self time:   0.000319

count  total (s)   self (s)
   96              0.000281     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 158 times
Total time:   0.019453
 Self time:   0.015907

count  total (s)   self (s)
  158              0.000489   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  158              0.000758   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  158              0.000065   endif
  158              0.001090   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  158              0.000398   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
  158              0.000075   endif
  158   0.004542   0.000996   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>39_DevIconsGetArtifactFix()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:544
Called 133 times
Total time:   0.001152
 Self time:   0.001152

count  total (s)   self (s)
  133              0.000235   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  133              0.000079   else
  133              0.000193     let artifactFix = ''
  133              0.000079   endif
                            
  133              0.000177   return artifactFix

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 4 times
Total time:   0.000055
 Self time:   0.000026

count  total (s)   self (s)
    4   0.000051   0.000022   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitstatus#util#ParseGitStatusLine()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:174
Called 3 times
Total time:   0.000110
 Self time:   0.000081

count  total (s)   self (s)
    3              0.000007     if get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2
    3              0.000004         if a:statusLine[0] ==# '1'
    3   0.000049   0.000020             let l:statusKey = s:getStatusKey(a:statusLine[2], a:statusLine[3])
    3              0.000005             let l:pathStr = a:statusLine[113:]
                                    elseif a:statusLine[0] ==# '2'
                                        let l:statusKey = 'Renamed'
                                        let l:pathStr = a:statusLine[113:]
                                        let l:pathStr = l:pathStr[stridx(l:pathStr, ' ')+1:]
                                    elseif a:statusLine[0] ==# 'u'
                                        let l:statusKey = 'Unmerged'
                                        let l:pathStr = a:statusLine[161:]
                                    elseif a:statusLine[0] ==# '?'
                                        let l:statusKey = 'Untracked'
                                        let l:pathStr = a:statusLine[2:]
                                    elseif a:statusLine[0] ==# '!'
                                        let l:statusKey = 'Ignored'
                                        let l:pathStr = a:statusLine[2:]
                                    else
                                        throw '[nerdtree_git_status] unknown status: ' . a:statusLine
    3              0.000001         endif
    3              0.000004         return [l:pathStr, l:statusKey]
                                else
                                    let l:pathStr = a:statusLine[3:]
                                    let l:statusKey = s:getStatusKey(a:statusLine[0], a:statusLine[1])
                                    return [l:pathStr, l:statusKey]
                                endif

FUNCTION  <SNR>81_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:185
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000010   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000002     return
                              endif
                              unlet! b:airline_whitespace_check
                              if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
                              endif
                              let b:airline_ws_changedtick = b:changedtick

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 158 times
Total time:   0.012853
 Self time:   0.004304

count  total (s)   self (s)
  158              0.000587   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  158              0.000068   endif
  158   0.009897   0.001348   return {b:source_func}()

FUNCTION  <SNR>70_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 8 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
    8              0.000019   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    8              0.000006   endfor
                            
   32              0.000038   for matchw in g:airline_exclude_filenames
   24              0.000138     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   24              0.000010     endif
   32              0.000017   endfor
                            
    8              0.000012   if g:airline_exclude_preview && &previewwindow
                                return 1
    8              0.000004   endif
                            
    8              0.000006   return 0

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 8 times
Total time:   0.000307
 Self time:   0.000107

count  total (s)   self (s)
    8   0.000158   0.000041   let summary = gitgutter#hunk#summary(a:bufnr)
    8              0.000012   let summary[1] += a:count
    8   0.000132   0.000048   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>77_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:29
Called 180 times
Total time:   0.001182
 Self time:   0.001182

count  total (s)   self (s)
  180              0.000473   if index(a:list, a:name) == -1
  180              0.000426     call add(a:list, a:name)
  180              0.000153     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:156
Called 4 times
Total time:   0.013949
 Self time:   0.000243

count  total (s)   self (s)
    4   0.000145   0.000026   if airline#util#stl_disabled(winnr())
                                return
    4              0.000002   endif
    8              0.000011   for nr in a:range
    4   0.000147   0.000024     if airline#util#stl_disabled(nr)
                                  continue
    4              0.000002     endif
    4              0.000011     call setwinvar(nr, 'airline_active', 0)
    4              0.000017     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    4              0.000008     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    4              0.000002     endif
    4   0.013511   0.000048     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    8              0.000007   endfor

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:202
Called 342 times
Total time:   0.002437
 Self time:   0.002437

count  total (s)   self (s)
  342              0.002276     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>117_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 20 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   20              0.000032   return a:from_count == 0 && a:to_count > 0

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim:3
Called 4 times
Total time:   0.010254
 Self time:   0.000638

count  total (s)   self (s)
    4              0.000024   let visible = tabpagebuflist()
                            
   24              0.000061   for bufnr in range(1, bufnr('$') + 1)
   20              0.000047     if buflisted(bufnr)
    4              0.000107       let file = expand('#'.bufnr.':p')
    4              0.000010       if !empty(file)
    4              0.000015         if index(visible, bufnr) != -1
    4   0.009678   0.000061           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    4              0.000004         endif
    4              0.000002       endif
   20              0.000013     endif
   24              0.000026   endfor

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:26
Called 4 times
Total time:   0.000074
 Self time:   0.000074

count  total (s)   self (s)
    4              0.000014   if getbufvar(a:2.bufnr, '&buftype') ==? 'terminal'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    4              0.000002   endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:240
Called 8 times
Total time:   0.100806
 Self time:   0.013396

count  total (s)   self (s)
    8              0.000017   let bufnr = a:0 ? a:1 : ''
    8              0.000025   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    8              0.000055   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    8              0.000019   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    8              0.000013   let airline_grouplist = []
    8              0.000051   let buffers_in_tabpage = sort(tabpagebuflist())
    8              0.000016   if exists("*uniq")
    8              0.000026     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    8              0.000004   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   16              0.000028   for mode in reverse(mapped)
    8              0.000041     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    6              0.000020       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  138              0.000232       for kvp in items(dict)
  132              0.000216         let mode_colors = kvp[1]
  132              0.000192         let name = kvp[0]
  132              0.000314         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  132              0.000063         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  132              0.000648         if name =~# 'airline_c\d\+'
   12              0.000081           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   12              0.000033           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
    6              0.000004             continue
    6              0.000003           endif
  120              0.000491         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   66              0.000048           continue
   60              0.000026         endif
   60   0.000842   0.000445         if s:group_not_done(airline_grouplist, name.suffix)
   60   0.015194   0.000466           call airline#highlighter#exec(name.suffix, mode_colors)
   60              0.000032         endif
                            
   60              0.000114         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
   60              0.000030         endif
                            
  180              0.000269         for accent in keys(s:accents)
  120              0.000266           if !has_key(p.accents, accent)
                                        continue
  120              0.000053           endif
  120              0.000339           let colors = copy(mode_colors)
  120              0.000239           if p.accents[accent][0] != ''
   60              0.000139             let colors[0] = p.accents[accent][0]
  120              0.000059           endif
  120              0.000209           if p.accents[accent][2] != ''
   60              0.000128             let colors[2] = p.accents[accent][2]
  120              0.000056           endif
  120              0.000188           if len(colors) >= 5
  120              0.000373             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  120              0.000061           endif
  120   0.001775   0.000990           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  120   0.030269   0.000998             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  120              0.000062           endif
  180              0.000112         endfor
   66              0.000036       endfor
                            
    6              0.000011       if empty(s:separators)
                                    " nothing to be done
                                    continue
    6              0.000003       endif
                                  " TODO: optimize this
   84              0.000137       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   78   0.042957   0.000728         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   84              0.000047       endfor
    8              0.000003     endif
   16              0.000019   endfor

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:31
Called 114 times
Total time:   0.000951
 Self time:   0.000951

count  total (s)   self (s)
  114              0.000604   if empty(s:client) || s:client['running'] == 0
                                return 0
  114              0.000053   endif
  114              0.000085   return 1

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 158 times
Total time:   0.004161
 Self time:   0.004161

count  total (s)   self (s)
  158              0.000488   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  158              0.000275   let bomb     = &bomb ? '[BOM]' : ''
  158              0.000702   let noeolf   = &eol ? '' : '[!EOL]'
  158              0.001027   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  158              0.000691   if expected is# &fenc.bomb.noeolf.ff
                                return ''
  158              0.000066   else
  158              0.000574     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:6
Called 7 times
Total time:   0.000534
 Self time:   0.000368

count  total (s)   self (s)
    7              0.000019   let fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
    7              0.000021   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    7              0.000007   let _ = ''
                            
    7              0.000017   let name = bufname(a:bufnr)
    7              0.000012   if empty(name)
                                let _ .= '[No Name]'
    7              0.000043   elseif name =~ 'term://'
                                " Neovim Terminal
                                let _ = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
    7              0.000003   else
    7              0.000015     if get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                  " Does not handle non-ascii characters like Cyrillic: 'D/Учёба/t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    7              0.000037       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
    7              0.000004     endif
    7              0.000019     if a:bufnr != bufnr('%') && fnametruncate && strlen(_) > fnametruncate
                                  let _ = airline#util#strcharpart(_, 0, fnametruncate)
    7              0.000003     endif
    7              0.000003   endif
                            
    7   0.000241   0.000076   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 19 times
Total time:   0.000330
 Self time:   0.000300

count  total (s)   self (s)
   19              0.000200   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   15              0.000021     return a:arg
    4   0.000057   0.000027   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    4              0.000003   else
    4              0.000013     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:136
Called 158 times
Total time:   0.003465
 Self time:   0.003465

count  total (s)   self (s)
  158              0.000919   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  158              0.002367   return match(a:name, pat) > -1

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000006   return s:available

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 52 times
Total time:   0.000454
 Self time:   0.000454

count  total (s)   self (s)
   52              0.000076   let x = a:i - 1
   56              0.000057   while x >= 0
   48              0.000088     let group = a:sections[x][0]
   48              0.000076     if group != '' && group != '|'
   44              0.000041       return group
    4              0.000002     endif
    4              0.000005     let x = x - 1
   12              0.000008   endwhile
    8              0.000006   return ''

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:493
Called 70 times
Total time:   0.013099
 Self time:   0.012493

count  total (s)   self (s)
   70              0.000101   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
   70              0.000039   else
   70              0.000273     let fileNodeExtension = fnamemodify(a:1, ':e')
   70              0.000220     let fileNode = fnamemodify(a:1, ':t')
   70              0.000088     if a:0 > 1
   21              0.000046       let isDirectory = a:2
   49              0.000025     else
   49              0.000062       let isDirectory = 0
   70              0.000040     endif
   70              0.000036   endif
                            
   70              0.000142   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
   70              0.000162     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   70              0.000210     let fileNodeExtension = tolower(fileNodeExtension)
   70              0.000180     let fileNode = tolower(fileNode)
                            
  700              0.001465     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
  630              0.003912       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
  630              0.000305       endif
  700              0.000410     endfor
                            
   70              0.000163     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
   70              0.000225       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
    6              0.000018         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
   64              0.000351       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   43              0.000144         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   21              0.000032       elseif isDirectory == 1
   18              0.000053         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   70              0.000043       endif
   70              0.000037     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
   70              0.000039   endif
                            
   70   0.001336   0.000730   let artifactFix = s:DevIconsGetArtifactFix()
                            
   70              0.000131   return symbol . artifactFix
                            

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:82
Called 3 times
Total time:   0.000622
 Self time:   0.000066

count  total (s)   self (s)
    3   0.000617   0.000062   return s:AsyncRequest(a:name, a:000)

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:49
Called 158 times
Total time:   0.000605
 Self time:   0.000605

count  total (s)   self (s)
  158              0.000498   return get(s:parts, a:key, {})

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 4 times
Total time:   0.000161
 Self time:   0.000060

count  total (s)   self (s)
    4   0.000080   0.000021   let summary = gitgutter#hunk#summary(a:bufnr)
    4              0.000006   let summary[2] += a:count
    4   0.000068   0.000025   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 158 times
Total time:   0.000472
 Self time:   0.000472

count  total (s)   self (s)
  158              0.000368   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:127
Called 4 times
Total time:   0.046418
 Self time:   0.000267

count  total (s)   self (s)
    4   0.000172   0.000029   if airline#util#stl_disabled(winnr())
                                return
    4              0.000002   endif
    4              0.000039   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.013981   0.000032   call airline#update_statusline_inactive(range)
                            
    4              0.000008   unlet! w:airline_render_left w:airline_render_right
    4              0.000045   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000006   let w:airline_active = 1
    4              0.000019   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.032124   0.000065   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 4 times
Total time:   0.004511
 Self time:   0.003750

count  total (s)   self (s)
    4              0.000009   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    4              0.000064     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    4   0.000065   0.000033     let modified_lines = s:handle_double_hunk(a:modified_lines)
    4   0.003003   0.002273     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    4              0.000009     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
    4              0.000002     endif
                            
  256              0.000149     for sign in signs
  252              0.001020       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
  256              0.000103     endfor
    4              0.000002     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:146
Called 4 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    4              0.000020   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    4              0.000005   endif

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 4 times
Total time:   0.008100
 Self time:   0.000889

count  total (s)   self (s)
    4   0.000131   0.000034   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    4              0.000003   endif
                            
    4   0.000126   0.000035   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    4              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    4              0.000006   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    4              0.000016   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    4              0.000011   let s:counter = (s:counter + 1) % 20
    4              0.000013   let buff_file .= '.'.s:counter
                            
    4   0.000226   0.000035   let extension = gitgutter#utility#extension(a:bufnr)
    4              0.000009   if !empty(extension)
    4              0.000011     let buff_file .= '.'.extension
    4              0.000003   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    4   0.000725   0.000062   call s:write_buffer(a:bufnr, buff_file)
                            
    4              0.000007   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    4              0.000016     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    4              0.000011     let from_file .= '.'.s:counter
                            
    4              0.000009     if !empty(extension)
    4              0.000010       let from_file .= '.'.extension
    4              0.000003     endif
                            
                                " Write file from index to temporary file.
    4   0.000458   0.000098     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000029     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    4              0.000003   endif
                            
                              " Call git-diff.
    4              0.000016   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    4              0.000005   if s:c_flag
    4              0.000009     let cmd .= ' -c "diff.autorefreshindex=0"'
    4              0.000009     let cmd .= ' -c "diff.noprefix=false"'
    4              0.000009     let cmd .= ' -c "core.safecrlf=false"'
    4              0.000003   endif
    4              0.000024   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    4              0.000013   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    4   0.000166   0.000046     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    4              0.000003   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    4              0.000010   let cmd .= ' || exit 0'
                            
    4              0.000009   let cmd .= ')'
                            
    4   0.000635   0.000045   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    4   0.000043   0.000034   if g:gitgutter_async && gitgutter#async#available()
    4   0.005171   0.000083     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    4              0.000007     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 4 times
Total time:   0.010452
 Self time:   0.000440

count  total (s)   self (s)
    4   0.000142   0.000025   call gitgutter#debug#log(a:diff)
                            
    4              0.000008   if !bufexists(a:bufnr)
                                return
    4              0.000002   endif
                            
    4   0.000974   0.000054   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    4   0.004430   0.000048   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    4              0.000008   let signs_count = len(modified_lines)
    4              0.000008   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    4              0.000002   else
    4              0.000009     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    4   0.004623   0.000112       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    4              0.000002     endif
    4              0.000002   endif
                            
    4   0.000140   0.000057   call s:save_last_seen_change(a:bufnr)
    4              0.000044   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    4              0.000002   endif

FUNCTION  gitstatus#util#BuildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:59
Called 3 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    3              0.000033     let l:cmd = [ get(a:opts, 'NERDTreeGitStatusGitBinPath', 'git'), '-C', a:root, 'status', '--porcelain' . (get(a:opts, 'NERDTreeGitStatusPorcelainVersion', 2) ==# 2 ? '=v2' : ''), '-z' ]
    3              0.000007     if has_key(a:opts, 'NERDTreeGitStatusUntrackedFilesMode')
    3              0.000012         let l:cmd += ['--untracked-files=' . a:opts['NERDTreeGitStatusUntrackedFilesMode']]
    3              0.000002     endif
                            
    3              0.000007     if get(a:opts, 'NERDTreeGitStatusShowIgnored', 0)
                                    let l:cmd += ['--ignored=traditional']
    3              0.000001     endif
                            
    3              0.000006     if has_key(a:opts, 'NERDTreeGitStatusIgnoreSubmodules')
                                    let l:cmd += ['--ignore-submodules=' . a:opts['NERDTreeGitStatusIgnoreSubmodules']]
    3              0.000001     endif
                            
    3              0.000003     return l:cmd

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 167 times
Total time:   0.006243
 Self time:   0.002778

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  167   0.004960   0.001495   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
    9              0.000007     return ''
  158              0.000077   endif
  158              0.000313   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  158              0.000068   else
  158              0.000255     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>115_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 4 times
Total time:   0.010573
 Self time:   0.000121

count  total (s)   self (s)
    4              0.000006   if !a:exit_code
    4   0.010556   0.000104     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    4              0.000002   endif

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 40 times
Total time:   0.000468
 Self time:   0.000468

count  total (s)   self (s)
   40              0.000053   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   40              0.000076   let ggvars = getbufvar(buffer, 'gitgutter')
   40              0.000069   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   40              0.000017   endif
   40              0.000091   let ggvars[a:varname] = a:val

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:170
Called 174 times
Total time:   0.000654
 Self time:   0.000654

count  total (s)   self (s)
  174              0.000573     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 32 times
Total time:   0.009731
 Self time:   0.000682

count  total (s)   self (s)
   32              0.000052   if a:group1 == a:group2
                                return 0
   32              0.000013   endif
   32   0.004774   0.000230   let color1 = airline#highlighter#get_highlight(a:group1)
   32   0.004742   0.000236   let color2 = airline#highlighter#get_highlight(a:group2)
   32              0.000102   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 316 times
Total time:   0.010970
 Self time:   0.010970

count  total (s)   self (s)
  316              0.010467   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
  316              0.000257     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  <SNR>50_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim:186
Called 114 times
Total time:   0.008060
 Self time:   0.007331

count  total (s)   self (s)
  114   0.001655   0.000925   let channel = coc#client#get_channel(self)
  114              0.000177   if empty(channel)
                                return ''
  114              0.000048   endif
  114              0.000094   try
  114              0.000103     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  114              0.000078     else
  114              0.002913       call call('rpcnotify', [channel, a:method] + a:args)
  114              0.000068     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  114              0.000116   endtry

FUNCTION  nerdtree#exec()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:157
Called 3 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    3              0.000012     let old_ei = &eventignore
    3              0.000005     if a:ignoreAll
    3              0.000033         set eventignore=all
    3              0.000003     endif
    3              0.000003     try
    3              0.000067         exec a:cmd
    3              0.000005     finally
    3              0.000014         let &eventignore = old_ei
    3              0.000004     endtry

FUNCTION  <SNR>115_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000005   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    4              0.000001   endif

FUNCTION  airline#extensions#fzf#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:37
Called 4 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    4              0.000011   if getbufvar(a:2.bufnr, '&filetype') ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    4              0.000002   endif

FUNCTION  <SNR>41_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 26 times
Total time:   0.001019
 Self time:   0.001019

count  total (s)   self (s)
   26              0.000512   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   26              0.000378   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   26              0.000076   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>118_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 252 times
Total time:   0.000729
 Self time:   0.000729

count  total (s)   self (s)
  252              0.000287   if a:text ==# 'added'
  232              0.000185     return 'GitGutterLineAdded'
   20              0.000019   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
   20              0.000021   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   20              0.000019   elseif a:text ==# 'modified'
   16              0.000013     return 'GitGutterLineModified'
    4              0.000004   elseif a:text ==# 'modified_removed'
    4              0.000003     return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:105
Called 302 times
Total time:   0.069208
 Self time:   0.014970

count  total (s)   self (s)
  302              0.000393   if pumvisible()
                                return
  302              0.000129   endif
  302              0.000412   let colors = a:colors
  302              0.000298   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  302              0.000136   endif
  302   0.047251   0.002273   let old_hi = airline#highlighter#get_highlight(a:group)
  302              0.000482   if len(colors) == 4
  114              0.000196     call add(colors, '')
  302              0.000139   endif
  302              0.001827   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  302   0.007496   0.001906   let colors = s:CheckDefined(colors)
  302   0.005745   0.002073   if old_hi != new_hi || !s:hl_group_exists(a:group)
                                let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
                                exe cmd
                                if has_key(s:hl_groups, a:group)
                                  let s:hl_groups[a:group] = colors
                                endif
  302              0.000121   endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 19 times
Total time:   0.000547
 Self time:   0.000283

count  total (s)   self (s)
   19   0.000386   0.000170   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   19   0.000146   0.000097   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  nerdtree#renderView()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:245
Called 3 times
Total time:   0.022977
 Self time:   0.000014

count  total (s)   self (s)
    3   0.022975   0.000012     call b:NERDTree.render()

FUNCTION  <SNR>72_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:177
Called 8 times
Total time:   0.045523
 Self time:   0.000407

count  total (s)   self (s)
    8   0.000249   0.000061   let builder = airline#builder#new(a:context)
    8   0.007034   0.000100   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    8              0.000008   if err == 1
    8   0.038053   0.000059     let a:context.line = builder.build()
    8              0.000049     let s:contexts[a:context.winnr] = a:context
    8              0.000023     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    8              0.000087     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    8              0.000004   endif

FUNCTION  <SNR>47_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim:231
Called 111 times
Total time:   0.011738
 Self time:   0.001098

count  total (s)   self (s)
  111              0.000186   if !g:coc_workspace_initialized
                                return
  111              0.000049   endif
  111   0.011306   0.000666   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim:33
Called 7 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
    7              0.000024   let buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
    7              0.000018   let buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
    7              0.000019   let buf_modified_symbol = g:airline_symbols.modified
                            
    7              0.000016   let _ = buf_nr_show ? printf(buf_nr_format, a:bufnr) : ''
    7              0.000034   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    7              0.000017   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= buf_modified_symbol
    7              0.000003   endif
    7              0.000006   return _

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 4 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000032   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 158 times
Total time:   0.003444
 Self time:   0.003444

count  total (s)   self (s)
  158              0.001469   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  158              0.000269   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  158              0.000062   endif
  158              0.000111   return ''

FUNCTION  <SNR>115_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 8 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    8              0.000014   if empty(self.stdoutbuffer)
    4              0.000006     let self.stdoutbuffer = a:data
    4              0.000001   else
    4              0.000025     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    8              0.000003   endif

FUNCTION  <SNR>34_hasPrefix()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:217
Called 3 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    3              0.000015     return len(a:text) >= len(a:prefix) && a:text[:len(a:prefix)-1] ==# a:prefix

FUNCTION  <SNR>77_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:41
Called 2376 times
Total time:   0.047593
 Self time:   0.047593

count  total (s)   self (s)
 2376              0.002529   let color = ''
 2376              0.008508   if hlexists(a:group)
 2296              0.012873     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 2376              0.001136   endif
 2376              0.004143   if empty(color) || color == -1
                                " should always exist
   80              0.000604     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
   80              0.000146     if empty(color) || color == -1
                                  let color = 'NONE'
   80              0.000032     endif
 2376              0.000911   endif
 2376              0.002042   return color

FUNCTION  207()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 69 times
Total time:   0.001412
 Self time:   0.000900

count  total (s)   self (s)
   69   0.000932   0.000420     let flags = self._flagsForScope(a:scope)
   69              0.000184     if index(flags, a:flag) == -1
   69              0.000187         call add(flags, a:flag)
   69              0.000048     end

FUNCTION  208()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 126 times
Total time:   0.000493
 Self time:   0.000493

count  total (s)   self (s)
  126              0.000434     let self._flags[a:scope] = []

FUNCTION  209()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 132 times
Total time:   0.000984
 Self time:   0.000984

count  total (s)   self (s)
  132              0.000379     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
  132              0.000077     endif
  132              0.000262     return self._flags[a:scope]

FUNCTION  <SNR>41_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 7 times
Total time:   0.000565
 Self time:   0.000098

count  total (s)   self (s)
    7   0.000561   0.000095   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  <SNR>41_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 4 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    4              0.000028   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>117_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 20 times
Total time:   0.004110
 Self time:   0.001241

count  total (s)   self (s)
   20              0.000026   let modifications = []
   20              0.000029   let from_line  = a:hunk[0]
   20              0.000027   let from_count = a:hunk[1]
   20              0.000025   let to_line    = a:hunk[2]
   20              0.000026   let to_count   = a:hunk[3]
                            
   20   0.000133   0.000094   if s:is_added(from_count, to_count)
   12   0.001049   0.000075     call s:process_added(modifications, from_count, to_count, to_line)
   12   0.000538   0.000085     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    8   0.000053   0.000038   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    8   0.000063   0.000043   elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    8   0.000066   0.000045   elseif s:is_modified_and_added(from_count, to_count)
    4   0.000644   0.000033     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    4   0.000182   0.000029     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    4   0.000167   0.000025     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    4   0.000042   0.000028   elseif s:is_modified_and_removed(from_count, to_count)
    4   0.000134   0.000035     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    4   0.000196   0.000030     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    4   0.000192   0.000031     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   20              0.000008   endif
   20              0.000019   return modifications

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 158 times
Total time:   0.001369
 Self time:   0.001369

count  total (s)   self (s)
  158              0.001267   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  212()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 48 times
Total time:   0.000861
 Self time:   0.000861

count  total (s)   self (s)
   48              0.000059     let flagstring = ''
  144              0.000178     for i in values(self._flags)
   96              0.000209         let flagstring .= join(i)
  144              0.000075     endfor
                            
   48              0.000074     if len(flagstring) == 0
                                    return ''
   48              0.000020     endif
                            
   48              0.000071     return '[' . flagstring . ']'

FUNCTION  217()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 3 times
Total time:   0.000442
 Self time:   0.000077

count  total (s)   self (s)
    3   0.000153   0.000018     call g:NERDTree.MustBeOpen()
    3   0.000286   0.000056     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  218()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 18 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
   18              0.000040     return exists('b:NERDTree')

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 158 times
Total time:   0.005176
 Self time:   0.005176

count  total (s)   self (s)
  158              0.000845   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  158              0.000517     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  158              0.000656     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  158              0.000405     let default = get(g:, 'airline#extensions#keymap#default', '')
  158              0.000194     if (label !=# '')
  158              0.000292       let label .= ' '
  158              0.000078     endif
  158              0.000230     let keymap = &keymap
  158              0.000321     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
  158              0.000074     endif
  158              0.000818     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  gitstatus#util#UpdateParentDirsStatus()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:203
Called 3 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    3              0.000011     let l:dirtyPath = fnamemodify(a:pathStr, ':h')
    3              0.000008     let l:dir_dirty_only = get(a:opts, 'NERDTreeGitStatusDirDirtyOnly', 1)
    6              0.000008     while l:dirtyPath !=# a:root
    3              0.000006         let l:key = get(a:cache, l:dirtyPath, '')
    3              0.000003         if l:dir_dirty_only
    3              0.000003             if l:key ==# ''
    3              0.000005                 let a:cache[l:dirtyPath] = 'Dirty'
                                        else
                                            return
    3              0.000001             endif
                                    else
                                        if l:key ==# ''
                                            let a:cache[l:dirtyPath] = a:statusKey
                                        elseif l:key ==# 'Dirty' || l:key ==# a:statusKey
                                            return
                                        else
                                            let a:cache[l:dirtyPath] = 'Dirty'
                                        endif
    3              0.000001         endif
    3              0.000008         let l:dirtyPath = fnamemodify(l:dirtyPath, ':h')
    6              0.000004     endwhile

FUNCTION  <SNR>51_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:77
Called 4 times
Total time:   0.047343
 Self time:   0.000081

count  total (s)   self (s)
    4   0.000072   0.000027   if airline#util#try_focusgained()
    4   0.047263   0.000046     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    4              0.000001   endif

FUNCTION  <SNR>117_is_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:289
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000011   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  234()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 3 times
Total time:   0.000393
 Self time:   0.000379

count  total (s)   self (s)
    3   0.000022   0.000016     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    3   0.000021   0.000014     elseif !self.isMinimal()
    3              0.000008         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
    3              0.000019         silent! put =help
    3              0.000002     endif

FUNCTION  <SNR>117_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 8 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    8              0.000017   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  223()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 12 times
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
   12              0.000043     if exists('t:NERDTreeBufName')
   12              0.000268         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  224()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 9 times
Total time:   0.000314
 Self time:   0.000065

count  total (s)   self (s)
    9   0.000307   0.000058     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 3 times
Total time:   0.000135
 Self time:   0.000031

count  total (s)   self (s)
    3   0.000123   0.000019     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    3              0.000003     endif

FUNCTION  229()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 117 times
Total time:   0.000584
 Self time:   0.000584

count  total (s)   self (s)
  117              0.000244     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
  117              0.000051     endif
  117              0.000117     return s:NERDTree._PathFilters

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim:188
Called 158 times
Total time:   0.005106
 Self time:   0.001312

count  total (s)   self (s)
  158   0.005014   0.001220   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 158 times
Total time:   0.005681
 Self time:   0.001490

count  total (s)   self (s)
  158   0.005579   0.001387   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>51_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:216
Called 4 times
Total time:   0.047217
 Self time:   0.000257

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    4              0.000015   let fast=!empty(get(a:000, 0, 0))
    4              0.000013   if !exists("#airline")
                                " disabled
                                return
    4              0.000002   endif
    4   0.000166   0.000032   call airline#util#doautocmd('AirlineBeforeRefresh')
    4   0.000421   0.000031   call airline#highlighter#reset_hlcache()
    4              0.000004   if !fast
                                call airline#load_theme()
    4              0.000002   endif
    4   0.046522   0.000104   call airline#update_statusline()
    4   0.000051   0.000033   call airline#update_tabline()

FUNCTION  <SNR>41_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 4 times
Total time:   0.000192
 Self time:   0.000041

count  total (s)   self (s)
    4   0.000190   0.000039   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 4 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000007   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    4              0.000002   endif

FUNCTION  <SNR>78_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:55
Called 158 times
Total time:   0.000969
 Self time:   0.000969

count  total (s)   self (s)
  158              0.000846   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  232()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 3 times
Total time:   0.022963
 Self time:   0.000019

count  total (s)   self (s)
    3   0.022961   0.000017     call self.ui.render()

FUNCTION  239()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000003     return self._showBookmarks

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 4 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    4              0.000025   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000015   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000006   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    4              0.000002   endif
                            
    4              0.000009   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    4              0.000002   endif

FUNCTION  <SNR>91_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 60 times
Total time:   0.002435
 Self time:   0.001960

count  total (s)   self (s)
   60              0.000147   if has_key(s:section_truncate_width, a:key)
   36   0.000559   0.000271     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
    4              0.000003       return ''
   32              0.000015     endif
   56              0.000024   endif
   56              0.000093   let spc = g:airline_symbols.space
   56              0.000197   if !exists('g:airline_section_{a:key}')
                                return ''
   56              0.000024   endif
   56   0.000676   0.000488   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   56              0.000293   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   56              0.000178   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>91_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 12 times
Total time:   0.004201
 Self time:   0.000624

count  total (s)   self (s)
   56              0.000061   for key in a:keys
   44              0.000101     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   44              0.000018     endif
   44   0.003883   0.000306     call s:add_section(a:builder, a:context, key)
   56              0.000035   endfor

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:217
Called 36 times
Total time:   0.019902
 Self time:   0.000497

count  total (s)   self (s)
   36              0.000181   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   36   0.019702   0.000298   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  240()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 108 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
  108              0.000113     return self._showFiles

FUNCTION  241()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000004     return self._showHelp

FUNCTION  245()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 120 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
  120              0.000141     return self._ignoreEnabled ==# 1

FUNCTION  246()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 9 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    9              0.000011     return g:NERDTreeMinimalUI

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 158 times
Total time:   0.008474
 Self time:   0.001199

count  total (s)   self (s)
  158   0.008371   0.001096   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 16 times
Total time:   0.000607
 Self time:   0.000211

count  total (s)   self (s)
   16   0.000313   0.000082   let summary = gitgutter#hunk#summary(a:bufnr)
   16              0.000022   let summary[0] += a:count
   16   0.000261   0.000096   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim:35
Called 7 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    7              0.000019   if exists('s:current_buffer_list')
    7              0.000007     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  gitstatus#shouldConceal()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus.vim:67
Called 6 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    6              0.000024     return has('conceal') && g:NERDTreeGitStatusConcealBrackets

FUNCTION  253()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 3 times
Total time:   0.022944
 Self time:   0.000506

count  total (s)   self (s)
    3              0.000020     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    3              0.000008     let curLine = line('.')
    3              0.000006     let curCol = col('.')
    3              0.000006     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    3              0.000078     silent 1,$delete _
                            
    3   0.000409   0.000016     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    3   0.000016   0.000012     if !self.isMinimal()
    3              0.000014         call setline(line('.')+1, '')
    3              0.000010         call cursor(line('.')+1, col('.'))
    3              0.000001     endif
                            
    3   0.000019   0.000014     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    3              0.000001     endif
                            
                                " add the 'up a dir' line
    3   0.000014   0.000010     if !self.isMinimal()
    3   0.000027   0.000022         call setline(line('.')+1, s:UI.UpDirLine())
    3              0.000008         call cursor(line('.')+1, col('.'))
    3              0.000001     endif
                            
                                " draw the header line
    3   0.000388   0.000026     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    3              0.000013     call setline(line('.')+1, header)
    3              0.000008     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    3   0.021724   0.000059     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    3              0.000018     silent 1,1delete _
                            
                                " restore the view
    3              0.000009     let old_scrolloff=&scrolloff
    3              0.000022     let &scrolloff=0
    3              0.000008     call cursor(topLine, 1)
    3              0.000053     normal! zt
    3              0.000006     call cursor(curLine, curCol)
    3              0.000009     let &scrolloff = old_scrolloff
                            
    3              0.000013     setlocal readonly nomodifiable

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:800
Called 3 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    3              0.000004   let invalids = []
    3              0.000003   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
    3              0.000002   else
    9              0.000014     for i in range(1, winnr('$'))
    6              0.000017       let target = getwinvar(i, 'target_winid', 0)
    6              0.000010       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
    6              0.000013       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
    6              0.000003       endif
    9              0.000005     endfor
    3              0.000001   endif
    3              0.000004   for id in invalids
                                call coc#float#close(id)
    3              0.000002   endfor

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 7 times
Total time:   0.001433
 Self time:   0.000240

count  total (s)   self (s)
    7   0.001426   0.000233   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  261()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000003     return '.. (up a dir)'

FUNCTION  262()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 63 times
Total time:   0.000841
 Self time:   0.000841

count  total (s)   self (s)
   63              0.000198     let newObj = copy(self)
   63              0.000132     let newObj.nerdtree = a:nerdtree
   63              0.000117     let newObj.subject = a:subject
   63              0.000115     let newObj.action = a:action
   63              0.000125     let newObj.params = a:params
   63              0.000080     return newObj

FUNCTION  264()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 63 times
Total time:   0.047132
 Self time:   0.003542

count  total (s)   self (s)
   63   0.001342   0.000501     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  189   0.001614   0.000587     for Listener in s:Notifier.GetListenersForEvent(a:event)
  126              0.000887         let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
  126   0.042647   0.000926         call l:Callback(event)
  189              0.000149     endfor

FUNCTION  265()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 63 times
Total time:   0.000450
 Self time:   0.000450

count  total (s)   self (s)
   63              0.000197     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
   63              0.000040     endif
   63              0.000089     return s:refreshListenersMap

FUNCTION  266()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 63 times
Total time:   0.001027
 Self time:   0.000577

count  total (s)   self (s)
   63   0.000793   0.000342     let listenersMap = s:Notifier.GetListenersMap()
   63              0.000194     return get(listenersMap, a:name, [])

FUNCTION  <SNR>101_newJob()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/job.vim:30
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000038     return extend(deepcopy(s:Job), { 'name': a:name, 'opts': a:opts })

FUNCTION  <SNR>117_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 4 times
Total time:   0.000612
 Self time:   0.000612

count  total (s)   self (s)
    4              0.000004   let offset = 0
   20              0.000020   while offset < a:from_count
   16              0.000050     let line_number = a:to_line + offset
   16              0.000035     call add(a:modifications, [line_number, 'modified'])
   16              0.000014     let offset += 1
   20              0.000009   endwhile
   80              0.000078   while offset < a:to_count
   76              0.000093     let line_number = a:to_line + offset
   76              0.000157     call add(a:modifications, [line_number, 'added'])
   76              0.000066     let offset += 1
   80              0.000031   endwhile

FUNCTION  <SNR>90_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:182
Called 52 times
Total time:   0.000469
 Self time:   0.000469

count  total (s)   self (s)
   52              0.000060   let start=1
                            
                              " do not check for inactive windows or the tabline
   52              0.000065   if a:self._context.active == 0
   16              0.000013     return 0
   36              0.000067   elseif get(a:self._context, 'tabline', 0)
                                return 0
   36              0.000031   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   36              0.000070   if get(g:, 'airline_skip_empty_sections', 0) == 0
   36              0.000024     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>77_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:57
Called 594 times
Total time:   0.002871
 Self time:   0.002871

count  total (s)   self (s)
  594              0.002625   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>34_buildGitStatusCommand()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:145
Called 3 times
Total time:   0.000115
 Self time:   0.000027

count  total (s)   self (s)
    3   0.000111   0.000023     return gitstatus#util#BuildGitStatusCommand(a:workdir, g:)

FUNCTION  <SNR>39_CursorHoldUpdate()
    Defined: ~/.vim/plugged/vim-devicons/plugin/webdevicons.vim:399
Called 3 times
Total time:   0.077128
 Self time:   0.000245

count  total (s)   self (s)
    3              0.000016   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    3              0.000003   endif
                            
    3   0.000183   0.000036   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
    3              0.000002   endif
                            
                              " Do not update when a special buffer is selected
    3              0.000016   if !empty(&l:buftype)
                                return
    3              0.000002   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
    3              0.000012   let l:winnr = winnr()
    3              0.000011   let l:altwinnr = winnr('#')
                            
    3   0.000470   0.000028   call g:NERDTree.CursorToTreeWin()
    3   0.053332   0.000032   call b:NERDTree.root.refreshFlags()
    3   0.023015   0.000021   call NERDTreeRender()
                            
    3              0.000012   exec l:altwinnr . 'wincmd w'
    3              0.000020   exec l:winnr . 'wincmd w'

FUNCTION  270()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:24
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000006     if a:level < self.level
    3              0.000002         return
                                endif
                                echomsg '[nerdtree-git-status] ' . a:msg

FUNCTION  271()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/log.vim:31
Called 3 times
Total time:   0.000128
 Self time:   0.000119

count  total (s)   self (s)
    3   0.000126   0.000116     echohl LineNr | call self.output(s:debug, a:msg) | echohl None

FUNCTION  277()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:31
Called 63 times
Total time:   0.012793
 Self time:   0.000350

count  total (s)   self (s)
   63   0.012763   0.000320     call self.callback(a:event)

FUNCTION  278()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:35
Called 63 times
Total time:   0.012442
 Self time:   0.001572

count  total (s)   self (s)
   63              0.000134     let l:path = a:event.subject
   63   0.010845   0.000384     let l:indicator = self.getIndicatorByPath(l:path)
   63   0.000596   0.000360     call l:path.flagSet.clearFlags('git')
   63              0.000100     if l:indicator !=# ''
    6   0.000078   0.000050         if gitstatus#shouldConceal()
                                        let l:indicator = printf(' %s ', l:indicator)
    6              0.000005         endif
    6   0.000185   0.000040         call l:path.flagSet.addFlag('git', l:indicator)
   63              0.000035     endif

FUNCTION  279()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:47
Called 63 times
Total time:   0.010461
 Self time:   0.002314

count  total (s)   self (s)
   63   0.008142   0.000542     let l:pathStr = gitstatus#util#FormatPath(a:path)
   63              0.000238     let l:statusKey = get(self.current, l:pathStr, '')
                            
   63              0.000159     if l:statusKey !=# ''
    6   0.000114   0.000059         return gitstatus#getIndicator(l:statusKey)
   57              0.000032     endif
                            
   57   0.000603   0.000348     if self.getOption('ShowClean', 0)
                                    return gitstatus#getIndicator('Clean')
   57              0.000031     endif
                            
   57   0.000606   0.000370     if self.getOption('ConcealBrackets', 0) && self.getOption('AlignIfConceal', 0)
                                    return ' '
   57              0.000030     endif
   57              0.000049     return ''

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim:769
Called 104 times
Total time:   0.003994
 Self time:   0.002136

count  total (s)   self (s)
  104   0.003378   0.001520   let id = coc#float#get_related(a:winid, 'scrollbar')
  104              0.000201   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  104              0.000053   endif

FUNCTION  <SNR>77_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:129
Called 302 times
Total time:   0.005590
 Self time:   0.005590

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  302              0.000793   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  302              0.000145   endif
  302              0.000809   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  302              0.000130   endif
                            
  302              0.000506   for val in a:colors
  302              0.000639     if !empty(val) && val !=# 'NONE'
  302              0.000316       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  242()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 117 times
Total time:   0.000166
 Self time:   0.000166

count  total (s)   self (s)
  117              0.000126     return self._showHidden

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:226
Called 8 times
Total time:   0.002140
 Self time:   0.000258

count  total (s)   self (s)
    8              0.000033   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000004   else
    8              0.000079     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    8              0.000005   endif
                            
    8              0.000013   if !empty(colors)
    8   0.001955   0.000074     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    8              0.000004   endif

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 158 times
Total time:   0.004738
 Self time:   0.001043

count  total (s)   self (s)
  158   0.004666   0.000971   return airline#extensions#nvimlsp#get('Error')

FUNCTION  280()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:65
Called 3 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    3              0.000007     let self.next = a:cache

FUNCTION  282()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:73
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000006     return self.current !=# self.next

FUNCTION  284()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:81
Called 3 times
Total time:   0.000102
 Self time:   0.000033

count  total (s)   self (s)
    3   0.000076   0.000014     if !g:NERDTree.IsOpen()
                                    return
    3              0.000001     endif
                            
    3   0.000017   0.000010     if !self.changed()
    3              0.000001         return
                                endif
                            
                                call self.update()
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                try
                                    call g:NERDTree.CursorToTreeWin()
                                    call b:NERDTree.root.refreshFlags()
                                    call NERDTreeRender()
                                finally
                                    noautocmd exec l:altwinnr . 'wincmd w'
                                    noautocmd exec l:winnr . 'wincmd w'
                                endtry

FUNCTION  285()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/listener.vim:105
Called 114 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
  114              0.000432     return get(self.opts, 'NERDTreeGitStatus' . a:name, a:default)

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim:95
Called 114 times
Total time:   0.011059
 Self time:   0.002047

count  total (s)   self (s)
  114   0.001685   0.000734   if !coc#rpc#ready()
                                return ''
  114              0.000050   endif
  114   0.009023   0.000963   call s:client['notify'](a:method, a:args)
  114              0.000095   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 158 times
Total time:   0.037582
 Self time:   0.018009

count  total (s)   self (s)
  158              0.000336   if !get(w:, 'airline_active', 0)
                                return ''
  158              0.000068   endif
                              " Cache values, so that it isn't called too often
  158   0.003921   0.002705   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  158              0.000070   endif
  158   0.014003   0.001150   let hunks = airline#extensions#hunks#get_raw_hunks()
  158              0.000169   let string = ''
  158   0.001785   0.001180   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  158              0.000246   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
  632              0.000715     for i in [0, 1, 2]
  474   0.006527   0.003082       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  474              0.002044         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  474              0.000231       endif
  632              0.000402     endfor
  158              0.000075   endif
  158   0.001980   0.001639   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
  158              0.000272     let string = string[0:-2]
  158              0.000076   endif
                            
  158              0.000239   let b:airline_hunks = string
  158              0.000266   let b:airline_changenr = b:changedtick
  158   0.001946   0.000833   let s:airline_winwidth = airline#util#winwidth()
  158              0.000158   return string

FUNCTION  <SNR>78_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim:60
Called 158 times
Total time:   0.008549
 Self time:   0.002474

count  total (s)   self (s)
  158   0.002247   0.001279   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
  158              0.000068   endif
  158   0.005995   0.000890   return GitGutterGetHunkSummary()

FUNCTION  <SNR>118_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 4 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    4              0.000015   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    4              0.000002   endif
                            
    4              0.000004   return a:modified_lines

FUNCTION  292()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 8 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    8              0.000025   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  294()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 44 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   44              0.000134   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 4 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    4              0.000005   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    4              0.000002   endif

FUNCTION  299()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 8 times
Total time:   0.037994
 Self time:   0.004280

count  total (s)   self (s)
    8              0.000010   let side = 1
    8              0.000008   let line = ''
    8              0.000008   let i = 0
    8              0.000018   let length = len(self._sections)
    8              0.000009   let split = 0
    8              0.000010   let is_empty = 0
    8              0.000011   let prev_group = ''
                            
   60              0.000066   while i < length
   52              0.000091     let section = self._sections[i]
   52              0.000074     let group = section[0]
   52              0.000080     let contents = section[1]
   52              0.000073     let pgroup = prev_group
   52   0.000848   0.000394     let prev_group = airline#builder#get_prev_group(self._sections, i)
   52              0.000108     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   52              0.000134     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000008       let group = 'airline_c'. self._context.bufnr
   48              0.000121     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000009       let prev_group = 'airline_c'. self._context.bufnr
   52              0.000022     endif
   52              0.000040     if is_empty
                                  let prev_group = pgroup
   52              0.000019     endif
   52   0.000818   0.000350     let is_empty = s:section_is_empty(self, contents)
                            
   52              0.000040     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   52              0.000020     endif
                            
   52              0.000048     if group == ''
                                  let line .= contents
   52              0.000050     elseif group == '|'
    8              0.000008       let side = 0
    8              0.000028       let line .= contents
    8              0.000008       let split = 1
   44              0.000018     else
   44              0.000042       if prev_group == ''
    8              0.000020         let line .= '%#'.group.'#'
   36              0.000025       elseif split
    4              0.000003         if !is_empty
    4   0.002496   0.000039           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    4              0.000002         endif
    4              0.000004         let split = 0
   32              0.000013       else
   32              0.000024         if !is_empty
   32   0.028958   0.000268           let line .= s:get_seperator(self, prev_group, group, side)
   32              0.000015         endif
   44              0.000023       endif
   44   0.002075   0.000431       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   52              0.000024     endif
                            
   52              0.000063     let i = i + 1
   60              0.000041   endwhile
                            
    8              0.000008   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    4              0.000090     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    8              0.000004   endif
    8              0.000015   return line

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 219 times
Total time:   0.002622
 Self time:   0.002622

count  total (s)   self (s)
  219              0.000933   let ggvars = getbufvar(a:buffer, 'gitgutter')
  219              0.000911   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  212              0.000377     return ggvars[a:varname]
    7              0.000005   endif
    7              0.000007   if a:0
    7              0.000009     return a:1
                              endif

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:61
Called 4 times
Total time:   0.000390
 Self time:   0.000390

count  total (s)   self (s)
    4              0.000388   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:63
Called 790 times
Total time:   0.004786
 Self time:   0.004786

count  total (s)   self (s)
  790              0.001555   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  790              0.000346   endif
  790              0.001838   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>61_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:39
Called 104 times
Total time:   0.012944
 Self time:   0.012944

count  total (s)   self (s)
                              " Remove any previous match.
  104              0.000291   if exists('w:paren_hl_on') && w:paren_hl_on
    1              0.000003     silent! call matchdelete(3)
    1              0.000001     let w:paren_hl_on = 0
  104              0.000045   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  104              0.000369   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  104              0.000044   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  104              0.000205   let c_lnum = line('.')
  104              0.000189   let c_col = col('.')
  104              0.000116   let before = 0
                            
  104              0.000272   let text = getline(c_lnum)
  104              0.001733   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  104              0.000165   if empty(matches)
                                let [c_before, c] = ['', '']
  104              0.000052   else
  104              0.000416     let [c_before, c] = matches[1:2]
  104              0.000056   endif
  104              0.001367   let plist = split(&matchpairs, '.\zs[:,]')
  104              0.000289   let i = index(plist, c)
  104              0.000106   if i < 0
                                " not found, in Insert mode try character before the cursor
  101              0.000226     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
  101              0.000049     endif
  101              0.000086     if i < 0
                                  " not found, nothing to do
  101              0.000075       return
                                endif
    3              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    3              0.000004   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    3              0.000002   else
    3              0.000004     let s_flags = 'nbW'
    3              0.000004     let c2 = c
    3              0.000006     let c = plist[i - 1]
    3              0.000002   endif
    3              0.000003   if c == '['
                                let c = '\['
                                let c2 = '\]'
    3              0.000002   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    3              0.000003   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    3              0.000002   endif
                            
    3              0.000023   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    3              0.000002   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    3              0.000012     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    3              0.000002     try
    3              0.000161       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    3              0.000002     endtry
    3              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    3              0.000008   let stoplinebottom = line('w$')
    3              0.000007   let stoplinetop = line('w0')
    3              0.000004   if i % 2 == 0
                                let stopline = stoplinebottom
    3              0.000001   else
    3              0.000006     let stopline = stoplinetop
    3              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    3              0.000009   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    3              0.000002   else
    3              0.000012     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    3              0.000002   endif
    3              0.000002   try
    3              0.004258     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    3              0.000003   endtry
                            
    3              0.000004   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    3              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    3              0.000007   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000002     if exists('*matchaddpos')
    1              0.000054       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    1              0.000001     endif
    1              0.000001     let w:paren_hl_on = 1
    3              0.000001   endif

FUNCTION  <SNR>34_onCursorHold()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:187
Called 3 times
Total time:   0.003480
 Self time:   0.000121

count  total (s)   self (s)
                                " Do not update when a special buffer is selected
    3              0.000006     if !empty(&l:buftype)
                                    return
    3              0.000001     endif
    3              0.000009     let l:fname = s:is_win ? substitute(a:fname, '\', '/', 'g') : a:fname
                            
    3   0.000042   0.000025     if !exists('g:NTGitWorkdir') || !s:hasPrefix(l:fname, g:NTGitWorkdir)
                                    return
    3              0.000001     endif
                            
    3   0.003240   0.000026     let l:job = s:refreshGitStatus('cursor-hold', g:NTGitWorkdir)
    3   0.000165   0.000037     call s:logger.debug('run cursor-hold job: ' . l:job.id)

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:71
Called 12 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
   12              0.000030     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  gitstatus#util#ParseGitStatusLines()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/autoload/gitstatus/util.vim:82
Called 3 times
Total time:   0.000377
 Self time:   0.000154

count  total (s)   self (s)
    3              0.000004     let l:result = {}
    3              0.000003     let l:is_rename = 0
    6              0.000007     for l:line in a:statusLines
    3              0.000002         if l:is_rename
                                        call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, a:root . '/' . l:line, 'Dirty', a:opts)
                                        let l:is_rename = 0
                                        continue
    3              0.000001         endif
    3   0.000134   0.000024         let [l:pathStr, l:statusKey] = gitstatus#util#ParseGitStatusLine(l:line, a:opts)
                            
    3              0.000006         let l:pathStr = a:root . '/' . l:pathStr
    3              0.000004         if l:pathStr[-1:-1] is# '/'
                                        let l:pathStr = l:pathStr[:-2]
    3              0.000001         endif
    3              0.000004         let l:is_rename = l:statusKey is# 'Renamed'
    3              0.000007         let l:result[l:pathStr] = l:statusKey
                            
    3   0.000138   0.000024         call gitstatus#util#UpdateParentDirsStatus(l:result, a:root, l:pathStr, l:statusKey, a:opts)
    6              0.000004     endfor
    3              0.000003     return l:result

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 4 times
Total time:   0.000218
 Self time:   0.000065

count  total (s)   self (s)
    4   0.000112   0.000031   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    4   0.000102   0.000030   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>91_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 44 times
Total time:   0.003577
 Self time:   0.001254

count  total (s)   self (s)
   44              0.000164     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   44   0.000587   0.000207     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   44              0.000024     endif
   44              0.000037     if condition
                                  call a:builder.add_raw('%(')
   44              0.000020     endif
   44   0.002439   0.000495     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   44              0.000042     if condition
                                  call a:builder.add_raw('%)')
   44              0.000022     endif

FUNCTION  <SNR>77_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:186
Called 114 times
Total time:   0.061633
 Self time:   0.004187

count  total (s)   self (s)
  114              0.000147   if pumvisible()
                                return
  114              0.000045   endif
  114              0.000282   let group = a:from.'_to_'.a:to.a:suffix
  114   0.017845   0.000803   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  114   0.017867   0.000790   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  114              0.000101   if a:inverse
   52              0.000165     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   62              0.000025   else
   62              0.000193     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  114              0.000047   endif
  114              0.000339   let a:dict[group] = colors
  114   0.024122   0.000794   call airline#highlighter#exec(group, colors)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:500
Called 158 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
  158              0.000247   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:229
Called 8 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    8              0.000054   let builder = copy(s:prototype)
    8              0.000015   let builder._context = a:context
    8              0.000012   let builder._sections = []
                            
    8              0.000083   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    8              0.000009   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  167   0.121549   0.017977  airline#check_mode()
    8   0.100806   0.013396  airline#highlighter#highlight()
   21   0.096308   0.000542  162()
  594   0.086213   0.035749  airline#highlighter#get_highlight()
    3   0.077128   0.000245  <SNR>39_CursorHoldUpdate()
  302   0.069208   0.014970  airline#highlighter#exec()
  114   0.061633   0.004187  <SNR>77_exec_separator()
   63   0.052057   0.000898  36()
 2376   0.047593             <SNR>77_get_syn()
    4   0.047343   0.000081  <SNR>51_on_focus_gained()
    4   0.047217   0.000257  <SNR>51_airline_refresh()
   63   0.047132   0.003542  264()
    4   0.046418   0.000267  airline#update_statusline()
    8   0.045523   0.000407  <SNR>72_invoke_funcrefs()
   51   0.041825   0.037443  131()
    8   0.037994   0.004280  299()
  158   0.037582   0.018009  airline#extensions#hunks#get_hunks()
  228   0.034118   0.001933  airline#themes#get_highlight()
   42   0.030974   0.000347  128()
   63   0.028929   0.007435  NERDTreeWebDevIconsRefreshListener()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2376              0.047593  <SNR>77_get_syn()
   51   0.041825   0.037443  131()
  594   0.086213   0.035749  airline#highlighter#get_highlight()
  158   0.037582   0.018009  airline#extensions#hunks#get_hunks()
  167   0.121549   0.017977  airline#check_mode()
  158   0.019453   0.015907  airline#extensions#whitespace#check()
  302   0.069208   0.014970  airline#highlighter#exec()
    8   0.100806   0.013396  airline#highlighter#highlight()
  104              0.012944  <SNR>61_Highlight_Matching_Pair()
   70   0.013099   0.012493  WebDevIconsGetFileTypeSymbol()
 1616              0.012090  airline#util#winwidth()
  316              0.010970  airline#extensions#nvimlsp#get()
 1106              0.009596  airline#util#append()
  174   0.018481   0.009102  38()
 1747   0.009767   0.008671  airline#util#wrap()
  474   0.011286   0.007499  airline#util#shorten()
   63   0.028929   0.007435  NERDTreeWebDevIconsRefreshListener()
  114   0.008060   0.007331  <SNR>50_notify()
  316              0.006955  airline#extensions#coc#get()
  302              0.005590  <SNR>77_CheckDefined()

